# 软件设计原则



### 1. 优秀设计特征

- **代码复用**

最底层，可以复用类；最高层，是可复用框架。

设计模式处于中间。

从低到高，复用程度增加。



- **扩展性**





### 2. 设计原则



#### 2.1 封装变化的内容

将程序分割成独立模块，尽可能将变化限制在隔间范围内。

- 方法层面的封装

```python
def getOrderTotal(order):
	total = 0
  
  # 计算原始总价
  for item in order.list:
    total += item.price * item.quantity
    
  # 计算税金
  if order.country == "US":
    total += total * 0.07
  elif order.country == "EU":
    total += total * 0.20
    
  return total
```

这样的方法，计算总价的代码和计算税金的代码混在一起。



```python
def getOrderTotal(order):
	total = 0
  
  # 计算原始总价
  for item in order.list:
    total += item.price * item.quantity
    
  # 计算税金
  total += total * getTaxRate(order.country)
    
  return total

# 获取税率
def getTaxRate(country):
  if order.country == "US":
    return 0.07
  elif order.country == "EU":
    return 0.20
  else:
  	return 0
```

修改后，税率相关代码隔离在了另一个方法内。



- 类层面的封装

现在将上面的例子用类封装实现。

```python
class Order:
  def __init__(self, list, country, state, city ...):
    self.list = list
    ...
    
  def getOrderTotal():
    ...
    
  def getTaxRate(counry, state, product):
    ...
```

修改前，计算总价和税金相关的代码在一个Order类里。



```python
class TaxCalculator:
  def getTaxRate(counry, state, product):
    ...
    
  def getUSTax(state):
    ...
    
  def getEUTax(country):
    ...
    
  def getChineseTax(product):
    ...

class Order:
  def __init__(self, taxCalculator, list, country, state, city ...):
    self.list = list
    ...
    
  def getOrderTotal():
    total = 0
    for item in self.list:
      subtotal = item.price * item.quantity
      total += subtotal * self.taxCalculator.getTaxRate(self.counry, self.state, item.product)
```

修改后，Order类看不见税金计算的代码。



#### 2.2 面向接口开发，而不是面向实现

通过接口的类之间互动比依赖具体类好得多。

如，导师只需要和学生「做科研」这部分打交道，而不需要了解他打游戏、谈恋爱等其他方面的事。

```python
class Company:
  def createSoftware():
    Designer d = new Designer()
    d.designArchitecture()
    Programmer p = new Programmer()
    p.writeCode()
    Tester t = new Tester()
    t.testSoftware()
    
class Designer:
  def designArchitecture():
    ...
    
class Programmer:
  def writeCode():
    ...
    
class Tester:
  def testSoftware():
    ...
```

这样设计，公司类和员工类之间耦合紧密。

可以利用多态修改。

```python
class Employee(Interface):
  def doWork():
    ...
    
class Designer(Employee):
class Programmer(Employee):
class Tester(Employee):
  
class Company:
  def __init__(self):
    self.employees = [
      new Designer(),
      new Programmer(),
      new Tester
    ]
  def createSoftware():
    for e in employees:
      e.doWork()
```

但是这样公司类仍然和员工类耦合，因为_\_init__中用到了几个员工类。



```python
class Employee(Interface):
  def doWork():
    ...
    
class Designer(Employee):
class Programmer(Employee):
class Tester(Employee):
  
class Company:
  def getEmployees():
    ...
    
  def createSoftware():
    employees = getEmployees()
    for e in employees:
      e.doWork()
      
class GameDevCompany(Company):
  def getEmployees():
    return [
      new Designer(),
      new Artist(),
      ...
    ]
    
class OutsourcingCompany(Company):
  def getEmployees():
    return [
      new Programmer(),
      new Tester(),
      ...
    ]
```

这样，公司类的方法与员工类相互独立，员工对象在具体公司子类中创建。



#### 2.3 组合优于继承

继承很简单使用，但它的缺点：

- 子类不能减少父类接口：即使这些接口对子类没用
- 重写方法，需要保证与父类版本兼容
- 继承打破了父类的封装
- 父类子类紧密耦合：父类的任何修改都可能破坏子类功能
- 平行继承体系：像下面看到的，会导致大量重复类出现



2种交通工具Truck和Car，每种有两种引擎Electric和Combustion，每种有两种控制方式Autopiloy和manual control.

设想用继承实现这个体系，最后具体子类有$2\times 2\times2$种，特征越多乘的越多。就像一个二叉树。但其实很多东西是重复的。

优化方法：用组合。交通工具可以由引擎、驾驶员两部分（以及更多东西）组合而成，引擎可以具体分为Electric和Combustion，驾驶员可以具体分为Autopiloy和manual control. 这样就大量减少了重复和类的数量。



### 3. SOLID原则



#### 3.1 Single Responsibility Principle单一职责原则







#### 3.2 Open/closed Principle开闭原则







#### 3.3 Liskov Substitution Principle里氏替换原则







#### 3.4 Interface Segregation Principle接口隔离原则







#### 3.5 Dependency Inversion Principle依赖倒置原则